<!doctype html>
<html>

<head>
    <title>{% if report_name and report_name != 'next' %}OneTask: {{ report_name.capitalize() }}{% else %}OneTask{% endif %}</title>
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <link rel="stylesheet" href="../static/css/style.css">
</head>

<body>
    <a href="/stats{{ '?report=' + request.args.get('report', 'next') }}" class="stats-link">Stats</a>
    <h1 class="task-name">{{ formatted_tasks[currentTaskIndex] }}</h1>
    <div class="task-id-display" onclick="copyTaskId()">
        ID: <span id="current-task-id">{{ short_ids[currentTaskIndex] }}</span>
    </div>
    <div id="countdown" class="countdown-box" onclick="toggleTimer()">
    </div>
    <div class="actions">
        <button onclick="goToPreviousTask()">
            << Previous
        </button>
        <button class="completeButton" onclick="completeTask()">Complete Task</button>
        <button onclick="skipToNextTask()">Next >></button>
    </div>
    <h2 class="url"><a href="#" target="_blank">Link</a></h2>
    
    <!-- Task Details Section (Hidden by default) -->
    <div id="task-details" class="task-details" style="display: none;">
        <div class="task-details-header">
            <h3>Task Details</h3>
            <button id="toggle-details" class="toggle-button">Hide</button>
        </div>
        
        <!-- Annotations Section -->
        <div class="details-section">
            <h4>Notes</h4>
            <div id="annotations-list"></div>
            <div class="annotation-form">
                <textarea id="new-annotation" placeholder="Add a note..." rows="3"></textarea>
                <button id="save-annotation">Save Note</button>
            </div>
        </div>
        
        <!-- Due Date Section -->
        <div class="details-section">
            <h4>Due Date</h4>
            <div id="due-date-display"></div>
            <div class="due-date-form">
                <input type="date" id="new-due-date">
                <button id="save-due-date">Save Due Date</button>
                <button id="remove-due-date">Remove</button>
            </div>
        </div>
        
        <!-- Tags Section -->
        <div class="details-section">
            <h4>Tags</h4>
            <div id="tags-display"></div>
        </div>
    </div>
    
    <!-- Tag Modal -->
    <div id="tag-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h3 id="modal-tag-title">Tasks with tag: </h3>
            <div id="modal-task-list"></div>
        </div>
    </div>
    
    <script type="text/javascript">
    // Get the remaining seconds from the app and convert it to a moment.js object
    var currentTaskIndex = 0; // Keep track of the current task index
    var taskUrl = {{ task_urls | tojson }}
    var numTasks = {{ num_tasks }}; // Total number of tasks
    var remainingSeconds = {{ remaining_seconds | tojson }};
    var formatted_tasks = {{ formatted_tasks | tojson }};
    var task_id = {{ task_id | tojson }};
    var taskseries_id = {{ taskseries_id | tojson }};
    var truelist_id = {{ truelist_id | tojson }};
    var short_ids = {{ short_ids | tojson }};
    var task_annotations = {{ task_annotations | tojson }};
    var task_due_dates = {{ task_due_dates | tojson }};
    var task_tags = {{ task_tags | tojson }};
    var remainingTime = moment.duration(remainingSeconds[currentTaskIndex], 'seconds');
    var countdownBox = document.querySelector('.countdown-box');
    var countdownInterval;
    var isPaused = false;
    var overdue = false;
    var completedTasks = [];
    var lastUpdateTime = moment();
    var taskDetailsVisible = false;

    // Function to update the link based on task URL
    function updateLink() {
        var url = taskUrl[currentTaskIndex];
        console.log('Task URL:', url);
        console.log('currentTaskIndex: ', currentTaskIndex);
        var linkElement = document.querySelector('.url a');

        // Check if task URL is "none" or empty
        if (!url || url.toLowerCase() === 'none') {
            linkElement.href = '#';
            linkElement.innerText = "";
        } else {
            // Check if task URL lacks http or https protocol
            // But preserve app links (custom protocols like joplin://, obsidian://, etc.)
            if (!url.startsWith('http://') && !url.startsWith('https://') && !url.includes('://')) {
                url = 'http://' + url; // Add http protocol only for domain-like URLs
            }
            linkElement.href = url;
            linkElement.innerText = "Link"; // Set inner text to the URL

        }
    }

    // Function to update the task ID display
    function updateTaskId() {
        var taskIdElement = document.getElementById('current-task-id');
        taskIdElement.textContent = short_ids[currentTaskIndex];
    }

    // Function to copy task ID to clipboard
    function copyTaskId() {
        var taskId = short_ids[currentTaskIndex];
        navigator.clipboard.writeText(taskId).then(function() {
            console.log('Task ID copied to clipboard: ' + taskId);
            // Visual feedback
            var taskIdDisplay = document.querySelector('.task-id-display');
            var originalText = taskIdDisplay.innerHTML;
            taskIdDisplay.innerHTML = 'ID: <span>Copied!</span>';
            setTimeout(function() {
                taskIdDisplay.innerHTML = originalText;
            }, 1000);
        }).catch(function(err) {
            console.error('Failed to copy task ID: ', err);
        });
    }

    // turn the timer on or off by clicking in the box
    function toggleTimer() {
        if (isPaused) {
            resumeTimer();
        } else {
            pauseTimer();
        }
    }

    function pauseTimer() {
        clearInterval(countdownInterval);
        countdownBox.style.backgroundColor = '#e6d7d7';
        countdownBox.style.color = '#c2c2c2';
        isPaused = true;
    }

    function resumeTimer() {
        if (overdue) {
            countdownBox.style.backgroundColor = '#df4343';
        } else {
            countdownBox.style.backgroundColor = '#4d4d4d';
        }
        countdownBox.style.color = '#f8f8f8';
        isPaused = false;
        lastUpdateTime = moment(); // Reset the update time when resuming
        countdownInterval = setInterval(updateCountdown, 1000); // Start the countdown interval
    }

    // button functions (updated versions are at the bottom of the script)

    function completeTask() {
        // Check if the task is completed
        if (isTaskCompleted(currentTaskIndex)) {
            // Perform uncomplete actions (e.g., restart the timer)
            uncompleteTask();
        } else {
            // Make a POST request to complete the task
            fetch('/complete_task', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'truelist_id': truelist_id[currentTaskIndex],
                    'taskseries_id': taskseries_id[currentTaskIndex],
                    'task_id': task_id[currentTaskIndex] })
            })
            .then(response => {
                console.log('task_id: ', task_id[currentTaskIndex])
                console.log('taskseries_id: ', taskseries_id[currentTaskIndex])
                console.log('truelist_id: ', truelist_id[currentTaskIndex])

                console.log('Response from server:', response);
                return response.json();})

            .then(data => {
                console.log('Completed Task: ', formatted_tasks[currentTaskIndex]);

                // Update the completedTasks array
                completedTasks.push(currentTaskIndex);

                // Update the UI with the completion status
                updateTaskName();
                skipToNextTask();
            })
            .catch(error => {
                console.error('Error completing task:', error);
            });
        }
    }

    function uncompleteTask() {
        // Make a POST request to uncomplete the task
        fetch('/uncomplete_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 'task_id': task_id[currentTaskIndex],
                'taskseries_id': taskseries_id[currentTaskIndex],
                'truelist_id': truelist_id[currentTaskIndex]
                 }),
        })
        .then(response => response.json())
        .then(data => {
            console.log('Uncompleted Task: ', formatted_tasks[currentTaskIndex]);

            // Remove the task index from completedTasks array
            completedTasks = completedTasks.filter(index => index !== currentTaskIndex);

            // Update the UI with the uncompletion status
            updateTaskName();
        })
        .catch(error => {
            console.error('Error uncompleting task:', error);
        });
    }

    function isTaskCompleted(index) {
        // Check if the task at the given index is in the completedTasks array
        return completedTasks.includes(index);
    }

    function updateTaskName() {
        var taskNameElement = document.querySelector('.task-name');
        var completeButtonElement = document.querySelector('.completeButton');
        taskNameElement.innerHTML = formatted_tasks[currentTaskIndex];

        // Check if the task is completed and apply the completed class
        if (isTaskCompleted(currentTaskIndex)) {
            taskNameElement.classList.add('completed');
            completeButtonElement.innerHTML = 'Uncomplete Task';

            // Stop the timer if the task is completed
            pauseTimer();
        } else {
            taskNameElement.classList.remove('completed');
            completeButtonElement.innerHTML = 'Complete Task';

            // Resume the timer if the task is not completed
            resumeTimer();
        }

        // Update the remaining time for the new task
        remainingTime = moment.duration(remainingSeconds[currentTaskIndex], 'seconds');
        updateCountdown();
    }

    // restore the default styles when a button is clicked.
    function restoreStyles() {
        countdownBox.style.backgroundColor = 'rgb(153, 149, 149)';
        document.body.style.backgroundColor = '#363636';
        overdue = false;
    }

    // Count down from the time estimate until 0 and then starting counting up from the time estimate
function updateCountdown() {
    if (isPaused) {
        return;
    }

    var now = moment();
    var elapsedTime = moment.duration(now.diff(lastUpdateTime)).asSeconds();
    lastUpdateTime = now;

    if (!overdue && remainingTime > 0) {
        // Counting down
        remainingTime.subtract(elapsedTime, 'seconds');
        
        if (remainingTime.asMinutes() >= 1) {
            var formattedTime = Math.ceil(remainingTime.asMinutes()) + " mins";
        } else if (remainingTime > 0) {
            var formattedTime = Math.ceil(remainingTime.asSeconds()) + " seconds";
        } else {
            // Timer just hit zero - switch to overdue mode
            remainingTime = moment.duration(remainingSeconds[currentTaskIndex], 'seconds');
            overdue = true;
            countdownBox.style.backgroundColor = '#df4343';
            document.body.style.backgroundColor = '#461818';
            formattedTime = Math.ceil(remainingTime.asMinutes()) + " mins";
        }
    } else {
        // Counting up (overdue time) - start from original estimate
        if (!overdue) {
            overdue = true;
            remainingTime = moment.duration(remainingSeconds[currentTaskIndex], 'seconds');
            countdownBox.style.backgroundColor = '#995151';
            document.body.style.backgroundColor = '#461818';
        }
        
        remainingTime.add(elapsedTime, 'seconds');
        
        // Always show only minutes when overdue (no seconds)
        formattedTime = Math.ceil(remainingTime.asMinutes()) + " mins";
    }

    // Update the countdown element
    document.getElementById('countdown').innerHTML = formattedTime;
    }

    // Keyboard navigation
    document.addEventListener('keydown', function(event) {
        // Don't trigger shortcuts when typing in input fields
        if (event.target.tagName === 'TEXTAREA' || event.target.tagName === 'INPUT') {
            return;
        }
        
        // Prevent default behavior for space bar to avoid page scrolling
        if (event.code === 'Space') {
            event.preventDefault();
        }
        
        switch(event.key.toLowerCase()) {
            case 'p':
                goToPreviousTask();
                break;
            case 'c':
                completeTask();
                break;
            case 'n':
                skipToNextTask();
                break;
            case ' ':
                toggleTimer();
                break;
            case 'i':
                toggleTaskDetails();
                break;
            case 'l':
                openTaskLink();
                break;
        }
    });

    // Link Functions
    function openTaskLink() {
        var url = taskUrl[currentTaskIndex];
        console.log('Opening task URL:', url);
        
        // Check if task URL is "none" or empty
        if (!url || url.toLowerCase() === 'none') {
            console.log('No link available for current task');
            return;
        }
        
        // Apply the same processing as updateLink function
        var processedUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://') && !url.includes('://')) {
            processedUrl = 'http://' + url; // Add http protocol only for domain-like URLs
        }
        
        // Open the link in a new window/tab
        window.open(processedUrl, '_blank');
    }

    // Task Details Functions
    function toggleTaskDetails() {
        const detailsDiv = document.getElementById('task-details');
        const toggleButton = document.getElementById('toggle-details');
        
        taskDetailsVisible = !taskDetailsVisible;
        
        if (taskDetailsVisible) {
            detailsDiv.style.display = 'block';
            toggleButton.textContent = 'Hide';
            updateTaskDetails();
        } else {
            detailsDiv.style.display = 'none';
            toggleButton.textContent = 'Show';
        }
    }

    function refreshCurrentTaskData() {
        const taskId = task_id[currentTaskIndex];
        
        // Fetch updated annotations
        fetch(`/task/${taskId}/annotations`)
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                task_annotations[currentTaskIndex] = data.annotations;
                if (taskDetailsVisible) {
                    updateAnnotationsDisplay();
                }
            }
        })
        .catch(error => console.error('Error refreshing annotations:', error));
        
        // Fetch updated due date
        fetch(`/task/${taskId}/due`)
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                task_due_dates[currentTaskIndex] = data.due_date;
                if (taskDetailsVisible) {
                    updateDueDateDisplay();
                }
            }
        })
        .catch(error => console.error('Error refreshing due date:', error));
    }

    function parseTaskWarriorDate(dateString) {
        if (!dateString) return null;
        
        let date;
        
        // Parse various TaskWarrior date formats
        if (dateString.match(/^\d{8}T\d{6}Z$/)) {
            // Format: "20251227T000000Z" (compact ISO)
            const year = dateString.substring(0, 4);
            const month = dateString.substring(4, 6);
            const day = dateString.substring(6, 8);
            const hour = dateString.substring(9, 11);
            const minute = dateString.substring(11, 13);
            const second = dateString.substring(13, 15);
            
            date = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}Z`);
        } else if (dateString.includes('T') && dateString.includes('Z')) {
            // Standard ISO format
            date = new Date(dateString);
        } else if (dateString.includes(' ')) {
            // Format: "2026-01-01 06:38:32"
            date = new Date(dateString.replace(' ', 'T') + 'Z');
        } else {
            // Fallback
            date = new Date(dateString);
        }
        
        return isNaN(date.getTime()) ? null : date;
    }

    function updateTaskDetails() {
        updateAnnotationsDisplay();
        updateDueDateDisplay();
        updateTagsDisplay();
    }

    function updateAnnotationsDisplay() {
        const annotationsList = document.getElementById('annotations-list');
        const annotations = task_annotations[currentTaskIndex] || [];
        
        annotationsList.innerHTML = '';
        
        annotations.forEach((annotation, index) => {
            const annotationDiv = document.createElement('div');
            annotationDiv.className = 'annotation-item';
            
            // Parse the annotation entry date
            const entryDate = parseTaskWarriorDate(annotation.entry);
            const dateDisplay = entryDate ? entryDate.toLocaleDateString() : 'Unknown date';
            
            annotationDiv.innerHTML = `
                <div class="annotation-text">${annotation.description}</div>
                <div class="annotation-meta">
                    <small>${dateDisplay}</small>
                    <button onclick="deleteAnnotation('${annotation.description.replace(/'/g, "\\'")}')" class="delete-btn">Delete</button>
                </div>
            `;
            annotationsList.appendChild(annotationDiv);
        });
        
        if (annotations.length === 0) {
            annotationsList.innerHTML = '<p class="no-items">No notes yet</p>';
        }
    }

    function updateDueDateDisplay() {
        const dueDateDisplay = document.getElementById('due-date-display');
        const dueDate = task_due_dates[currentTaskIndex];
        
        if (dueDate) {
            const parsedDate = parseTaskWarriorDate(dueDate);
            
            if (parsedDate) {
                dueDateDisplay.innerHTML = `<div class="due-date-item">${parsedDate.toLocaleDateString()}</div>`;
            } else {
                dueDateDisplay.innerHTML = `<div class="due-date-item">${dueDate} (parse error)</div>`;
            }
        } else {
            dueDateDisplay.innerHTML = '<p class="no-items">No due date set</p>';
        }
    }

    function updateTagsDisplay() {
        const tagsDisplay = document.getElementById('tags-display');
        const tags = task_tags[currentTaskIndex] || [];
        
        tagsDisplay.innerHTML = '';
        
        if (tags.length > 0) {
            tags.forEach(tag => {
                const tagElement = document.createElement('span');
                tagElement.className = 'tag-item';
                tagElement.textContent = tag;
                tagElement.onclick = () => showTagModal(tag);
                tagsDisplay.appendChild(tagElement);
            });
        } else {
            tagsDisplay.innerHTML = '<p class="no-items">No tags</p>';
        }
    }

    function saveAnnotation() {
        const newAnnotationText = document.getElementById('new-annotation').value.trim();
        
        if (!newAnnotationText) {
            alert('Please enter a note');
            return;
        }
        
        const taskId = task_id[currentTaskIndex];
        
        fetch(`/task/${taskId}/annotations`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ annotation: newAnnotationText })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                document.getElementById('new-annotation').value = '';
                // Refresh task data without page reload
                refreshCurrentTaskData();
            } else {
                alert('Error saving note: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error saving note');
        });
    }

    function deleteAnnotation(annotationText) {
        if (!confirm('Delete this note?')) return;
        
        const taskId = task_id[currentTaskIndex];
        
        // URL encode the annotation text for the API call
        const encodedText = encodeURIComponent(annotationText);
        
        fetch(`/task/${taskId}/annotations/${encodedText}`, {
            method: 'DELETE'
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Refresh task data without page reload
                refreshCurrentTaskData();
            } else {
                alert('Error deleting note: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error deleting note');
        });
    }

    function saveDueDate() {
        const newDueDate = document.getElementById('new-due-date').value;
        
        if (!newDueDate) {
            alert('Please select a date');
            return;
        }
        
        const taskId = task_id[currentTaskIndex];
        
        fetch(`/task/${taskId}/due`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ due_date: newDueDate })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                document.getElementById('new-due-date').value = '';
                // Refresh task data without page reload
                refreshCurrentTaskData();
            } else {
                alert('Error saving due date: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error saving due date');
        });
    }

    function removeDueDate() {
        if (!confirm('Remove due date?')) return;
        
        const taskId = task_id[currentTaskIndex];
        
        fetch(`/task/${taskId}/due`, {
            method: 'DELETE'
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Refresh task data without page reload
                refreshCurrentTaskData();
            } else {
                alert('Error removing due date: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error removing due date');
        });
    }

    function copyTaskIdFromModal(taskId, element) {
        navigator.clipboard.writeText(taskId).then(function() {
            console.log('Task ID copied to clipboard: ' + taskId);
            // Visual feedback
            const originalText = element.textContent;
            element.textContent = 'Copied!';
            element.style.color = '#4CAF50';
            setTimeout(function() {
                element.textContent = originalText;
                element.style.color = '';
            }, 1000);
        }).catch(function(err) {
            console.error('Failed to copy task ID: ', err);
        });
    }

    function showTagModal(tag) {
        fetch(`/tasks/by-tag/${tag}`)
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                const modal = document.getElementById('tag-modal');
                const title = document.getElementById('modal-tag-title');
                const taskList = document.getElementById('modal-task-list');
                
                title.textContent = `Tasks with tag: ${tag}`;
                
                taskList.innerHTML = '';
                
                if (data.tasks.length > 0) {
                    data.tasks.forEach(task => {
                        const taskDiv = document.createElement('div');
                        taskDiv.className = 'modal-task-item';
                        
                        // Create text nodes and clickable task ID span
                        const descriptionText = document.createTextNode(`${task.description} (`);
                        const closingParenText = document.createTextNode(')');
                        
                        const taskIdSpan = document.createElement('span');
                        taskIdSpan.textContent = task.short_id;
                        taskIdSpan.className = 'clickable-task-id';
                        taskIdSpan.title = 'Click to copy';
                        taskIdSpan.onclick = function() {
                            copyTaskIdFromModal(task.short_id, this);
                        };
                        
                        // Build the task display properly without innerHTML
                        taskDiv.appendChild(descriptionText);
                        taskDiv.appendChild(taskIdSpan);
                        taskDiv.appendChild(closingParenText);
                        
                        taskList.appendChild(taskDiv);
                    });
                } else {
                    taskList.innerHTML = '<p>No tasks found with this tag</p>';
                }
                
                modal.style.display = 'block';
            } else {
                alert('Error loading tasks: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error loading tasks');
        });
    }

    // Event listeners for buttons
    document.getElementById('toggle-details').onclick = toggleTaskDetails;
    document.getElementById('save-annotation').onclick = saveAnnotation;
    document.getElementById('save-due-date').onclick = saveDueDate;
    document.getElementById('remove-due-date').onclick = removeDueDate;

    // Modal close functionality
    document.getElementsByClassName('close')[0].onclick = function() {
        document.getElementById('tag-modal').style.display = 'none';
    }

    window.onclick = function(event) {
        const modal = document.getElementById('tag-modal');
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    }

    // Update task navigation functions to refresh details when visible
    function goToPreviousTask() {
        if (currentTaskIndex > 0) {
            currentTaskIndex--;
            updateTaskName();
            restoreStyles();
            updateLink();
            updateTaskId();
            if (taskDetailsVisible) {
                updateTaskDetails();
            }
        }
    }

    function skipToNextTask() {
        if (currentTaskIndex < numTasks - 1) {
            currentTaskIndex++;
            updateTaskName();
            restoreStyles();
            updateLink();
            updateTaskId();
            if (taskDetailsVisible) {
                updateTaskDetails();
            }
        }
    }

    // Start the countdown
    updateCountdown();
    updateLink();
    updateTaskId();
    // Schedule the next update in 1 second
    countdownInterval = setInterval(updateCountdown, 1000); 
    </script>
</body>
</html>